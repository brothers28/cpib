%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% NAT32 support for IML
% Module cpib
%
% This template was downloaded from:
% http://www.LaTeXTemplates.com
%
% Authors:
% Marco Romanutti
% Benjamin Meyer
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[10pt, a4paper, twocolumn]{article} % 10pt font size (11 and 12 also possible), A4 paper (letterpaper for US letter) and two column layout (remove for one column)

\input{structure.tex} % Specifies the document structure and loads requires packages

%----------------------------------------------------------------------------------------
%	ARTICLE INFORMATION
%----------------------------------------------------------------------------------------

\title{NAT32 und Casting für IML} % The article title

\author{
\authorstyle{Marco Romanutti\textsuperscript{1,2} und Benjamin Meyer\textsuperscript{1,2}} % Authors
\newline\newline % Space before institutions
\textsuperscript{1}\institution{Fachhochschule Nordwestschweiz FHNW, Brugg}\\ % Institution
\textsuperscript{2}\texttt{Schlussbericht} % Module
}

\date{}

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Print the title

\thispagestyle{firstpage} % Apply the page style for the first page (no headers and footers)

%----------------------------------------------------------------------------------------
%	ABSTRACT
%----------------------------------------------------------------------------------------

\lettrineabstract{Im Modul Compilerbau wird eine Erweiterung für die bestehende Sprache IML spezifiziert und implementiert. Die Implementierung beinhaltet einen neuen Datentyp für natürliche Zahlen, sowie eine Möglichkeit den Datentyp INT32 in den neuen Datentypen zu casten und umgekehrt.}
%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\section{Erweiterung}
\subsection{Einleitung}
Unter natürlichen Zahlen werden die positiven, ganzen Zahlen und 0 verstanden:

$$ \mathbb{N} = \{0; 1; 2; 3; \ldots\} $$

Die IML soll um einen neuen Datentyp \texttt{NAT32} erweitert werden.
Der neue Datentyp soll solche positiven, ganzen Zahlen bis Länge 32 in Binärdarstellung abbilden können.
Es sollen die bestehenden Operationen unterstützt werden.
Ausserdem soll ein explizites Casting zwischen dem bestehenden Datentyp \texttt{INT32} und dem neuen Datentyp \texttt{NAT32} möglich sein.

\subsection{Lexikalische Syntax}
Für den neuen Datentyp wird das Keyword \texttt{(TYPE, NAT32)} und ein Castingoperator hinzugefügt.

% Listing mit neuen Elementen
\begin{lstlisting}[backgroundcolor = \color{lightgray},
xleftmargin = 0.05cm,
framexleftmargin = 0.05em]
    Datentyp:     NAT32     (TYPE, NAT32)
    Brackets:     [ ]       LBRACKET, RBRACKET
\end{lstlisting}

Casting ist nur von \texttt{(TYPE, INT32)} zu \texttt{(TYPE, NAT32)} und umgekehrt möglich.
Als Castingoperator werden rechteckige Klammern (nachfolgend Brackets gennant) verwendet.
Innerhalb der Brackets befindet sich der Zieldatentyp \footnote{zum Beispiel \texttt{[INT32]}}.

\subsection{Grammatikalische Syntax}
Das nachfolgende Code-Listing zeigt, wie der neue Datentyp \texttt{NAT32} eingesetzt werden kann.
\begin{lstlisting}
    // Deklaration
    var natIdent1 : nat32;
    var natIdent2 : nat32;
    var natIdent3 : nat32;

    // Initialisierung
    natIdent1 init := [nat32] 50;
    natIdent2 init := [nat32] 10;
    natIdent3 init := natIdent1 + natIdent2;

    // Casting von INT32 nach NAT32
    var intIdent1 : int32;
    intIdent1 init := 30;
    natIdent3 := [nat32] intIdent1;

    call functionWithNatParam([nat32] intIdent1);

    // Casting von NAT32 nach INT32
    var intIdent2 : int32;
    intIdent2 init := [int32] natIdent3;

    call functionWithIntParam([int32] natIdent3);
\end{lstlisting}
Literale werden standardmässig als \texttt{INT32} interpretiert - ein \texttt{NAT32}-Literal bedingt vorab deshalb den Castingoperator.
Falls zwei Datentypen nicht gecastet werden können, wird ein Kompilierungsfehler geworfen.
Folgendes Code-Listing zeigt ein solches Beispiel mit dem bestehenden Datentyp \texttt{bool}:
\begin{lstlisting}
    // Deklaration
    var boolIdent : bool;
    boolIdent init := false;
    var natIdent : nat32;
    // Throws type checking error:
    natIdent init := [nat32] boolIdent
\end{lstlisting}
Unsere Erweiterung unterstützt keine impliziten Castings.
Weitere Code-Beispiele sind im Anhang zu finden.

Ebenfalls haben wir in unserer IML Syntax das logische Symbol für \texttt{AND: /\textbackslash{}} sowie \texttt{OR: \textbackslash{}/} durch \texttt{AND: \&\&} resp. \texttt{OR: ||} ersetzt.
Nach unserem Erachten, ist die Bedeutung von \texttt{\&\&} und \texttt{||} den meisten Programmierern besser bekannt, als \texttt{/\textbackslash{}} oder \texttt{\textbackslash{}/}.

\subsection{Änderungen an der Grammatik}
Zusätzlich zu den bestehende Operatoren wurde ein neuer \texttt{castOpr} erstellt, welcher anstelle des Nichtterminal-Symbol \texttt{factor} verwendet werden kann.
% Neuer Operator
\begin{lstlisting}[backgroundcolor = \color{lightgray},
xleftmargin = 0.05cm,
framexleftmargin = 0.05em]
    castOpr ::= LBRACKET TYPE RBRACKET
\end{lstlisting}
Das bestehende Nichtterminal-Symbol \texttt{factor} wird um diese neue Produktion ergänzt:
% Neue Produktionen
\begin{lstlisting}[backgroundcolor = \color{lightgray},
xleftmargin = 0.05cm,
framexleftmargin = 0.05em]
    factor ::= LITERAL
    | IDENT [INIT | exprList]
    | castOpr factor
    | monadicOpr factor
    | LPAREN expr RPAREN
\end{lstlisting}

\subsection{Kontext- und Typen-Einschränkungen}
Der \texttt{TYPE} zwischen \texttt{LBRACKET} und \texttt{RBRACKET} muss vom Datentyp \texttt{INT32} oder \texttt{NAT32} sein.
Ein Casting zum Typ \texttt{bool} oder vom Typ \texttt{bool} zu \texttt{INT32} resp. \texttt{NAT32} führt zu einem Kompilierungsfehler.

Tabelle \ref{tab:Casting} zeigt die unterstützen Typumwandlungen der verschiedenen Datentypen.
Typumwandlungen, welche zu potentiellen Laufzeitfehler führen, sind mit mit \texttt{*} gekennzeichnet.
Der Datentyp \texttt{INT32} umfasst einen Wertebereich von $-2147483648$ bis $2147483647$, wobei das Most Significant Bit (MSB) für das Vorzeichen verwendet wird.
Weil der Datentyp \texttt{NAT32} nur positive, ganze Zahlen und die Zahl 0 darstellt, wird kein Vorzeichenbit benötigt.
Der Wertebereich verschiebt sich dadurch auf $0$ bis $4294967295$.
Falls bei Typumwandlungen der Wert ausserhalb des Wertebereichs des Zieldatentyps liegt, führt dies zu einem Laufzeitfehler.
Bei der Umwandlung von \texttt{NAT32} nach \texttt{INT32} kann ein solcher Laufzeitfehler beispielsweise auftreten, falls es sich um einen Wert $> 2147483647$ handelt.
Falls negative Werte von \texttt{INT32} nach \texttt{NAT32} umgewandelt werden, resultiert ebenfalls ein Laufzeitfehler.
\begin{table}[h]
    \tiny
    \centering
    \caption{Casting zwischen Datentypen}
    \label{tab:Casting}
    \resizebox{\columnwidth}{!}{%
    \begin{tabular}{rlll}
        \hline
        Quell- \textbackslash \ Zieldatentyp & int32 & nat32 & bool \\ \hline
        int32 & \cmark        & \cmark *       & \xmark      \\
        nat32 & \cmark *      & \cmark         & \xmark     \\
        bool & \xmark        & \xmark         & \xmark     \\ \hline
    \end{tabular}%
    }
\end{table}

\section{Aufbau Compiler}
Der Compiler basiert auf der IML (V2) und ist in Java geschrieben.

\subsection{Scanner}
Literale werden standardmässig als \texttt{INT32} interpretiert - ein \texttt{NAT32}-Literal bedingt vorab deshalb den Castingoperator.
Vom Scanner werden Literale als \texttt{long} in Java eingelesen.
Dieser kann Werte von $-9223372036854775808$ bis $9223372036854775808$ annehmen und deckt somit den gesamten Wertebereich der beiden Datentypen \texttt{INT32} und \texttt{NAT32} ab.
Die Überprüfung, ob der Wert innerhalb des gültigen Wertebereichs des jeweiligen Datentyps liegt, erfolgt zum Zeitpunkt der Code-Generierung.

\subsection{Parser}
Der neu eingeführte \texttt{castOpr} und die neue Produktion \texttt{factor ::= castOpr factor} sind im Abstrakten Syntax Tree (AST) abgebildet.
Dabei wird der Typ \texttt{CastOpr} zum Typ \texttt{CastFactor} welcher Teil des AST ist.
Abbildung \ref{ast} zeigt die Umwandlung von der konkreten in die abstrakte Syntax.

\begin{figure}[H]
    \includegraphics[width=\linewidth]{uml_ast.png} % Figure image
    \caption{Umwandlung von der konkreten in die abstrakte Syntax} % Figure caption
    \label{ast}
\end{figure}

\subsection{Statische Analyse}

\subsubsection*{Scope checking}
Für Routinen und Variablen liegen unterschiedliche Namespaces vor.
Namen für Routinen und Variabeln können deshalb identisch sein.
Es wird zwischen globalen und lokalen Namespaces unterschieden: Bei lokalen Namespaces werden die Variable innerhalb einer Routine definiert und haben dort ihre Gültigkeit.
Globale Variabeln dürfen nicht denselben Namen haben wie lokalen Variabeln.
Überladene Signaturen für Routinen\footnote{selber Name, unterschiedliche Parameterlisten} wurde in dieser Implementation nicht umgesetzt.

Bei \textit{FunCallFactor, ProcCallCmd, DebugIn} und \textit{AssignCmd} muss überprüft werden, ob die Parameter den richtigen \texttt{LValue}, resp. \texttt{RValue} besitzen.
Folgende Kombinationen sind dabei allgemein erlaubt:

\begin{table}[h]
    \centering
    \tiny
    \caption{LRValue-Kombinationen}
    \label{tab:lrvalues}
    \resizebox{\columnwidth}{!}{%
    \begin{tabular}{@{}lll@{}}
        \toprule
        Callee & Caller & Resultat                       \\ \midrule
        LValue & LValue & Valid                          \\
        RValue & LValue & Valid (LValue dereferenzieren) \\
        RValue & RValue & Valid                          \\
        LValue & RValue & LRValueError \Lightning         \\ \bottomrule
    \end{tabular}%
    }
\end{table}
Bei einem \textit{AssignCmd} muss der Ausdruck links zudem zwingend ein \texttt{LValue} sein.
Bei einem \textit{DebugIn} muss es sich ebenfalls um einen \texttt{LValue} handeln, damit der Input-Wert dieser Variable zugewiesen werden kann.

Innerhalb des Scope checkings wird zudem überprüft, ob die Anzahl der erwarteten Parameter mit der Anzahl übergebener Parameter übereinstimmt.

\subsubsection*{Type checking}
Das Casten zwischen zwei Datentypen ist nur für bestimmte Typen erlaubt (vgl. Tabelle \ref{tab:Casting}).
Zusätzlich sind bei der Abarbeitung des AST nur die folgenden Typen erlaubt:

\begin{table}[h]
    \centering
    \tiny
    \caption{Erlaubte Typen}
    \label{tab:types}
    \resizebox{\columnwidth}{!}{%
    \begin{tabular}{@{}ll@{}}
        \toprule
        Klasse & Types \\ \midrule
        AddExpr, MultExpr, RelExpr      & \texttt{int32, nat32} * \\
        BoolExpr, IfCmd                 & \texttt{bool} \\
        AssignCmd                       & \texttt{int32, nat32, bool} * \\
        FunCallFactor, ProcCallFactor   & Typ von Caller muss \\
                                        & Typ von Callee entsprechen \\
        MonadicFactor                   & NOTOPR: \texttt{bool} \\
                                        & ADDOPR: \texttt{int32, nat32} \\
        CastFactor                      & Typ von Factor und \\
                                        & Typ von CastFactor \\
                                        & müssen castable sein\\ \bottomrule
    \end{tabular}%
    }
\end{table}
Bei Einträgen, die mit * gekennzeichnet sind, müssen \texttt{LValue} und \texttt{RValue} vom selben Typ sein.
Beim der Typenüberprüfung innerhalb vom \texttt{CastFactor} wird überprüft, ob der Typ vom \texttt{CastFactor} und jener des zugehörigen \texttt{factors} gecasted werden können (vgl. Tabelle \ref{tab:Casting}).
Die effektive Typ-Konversion wird erst bei der Code-Generierung durchgeführt.

\subsubsection*{Initalization checking}
Über das Interface \texttt{IAstNode} müssen alle Knotenpunkte vom AST, die Methode \texttt{executeInitCheck} implementieren.
Anhand nachfolgendem Besipielprogramm wird erklärt, wann welcher Initialisierungsfehler auftreten kann.
\begin{lstlisting}
program exampleInitErrors
global
    var x:int32;
    const y:int32
do
    x := 7; // throws NotInitializedError
    x init := 4;
    x init := 3; // throws AlreadyInitializedError
    y init := 1;
    y := 2 // throws CannotAssignToConstError
endprogram
\end{lstlisting}

\begin{itemize}
    \item \texttt{\textbf{NotInitializedError}}: Die Variable wurde zuvor nicht initialisiert.
    \item \texttt{\textbf{AlreadyInitializedError}}: Die Variable wurde bereits zuvor initialisiert.
    \item \texttt{\textbf{CannotAssignToConstError}}: Die Variable ist eine Konstante und wurde bereits inizialisiert.
\end{itemize}

Falls einer dieser Fehler auftritt, wird die Überprüfung sofort beendet und der Initialisierungscheck ist fehlgeschlagen.
Der AST wird während der Validierung Knoten für Knoten durchlaufen, wobei eine "Deep-First" Baumsuche angewendet wird.

\subsection{Virtuelle Maschine}
Grundlage für die Code-Generierung ist der AST.
Vom Root-Knoten ausgehend fügt jeder Knoten seinen Code zum Code-Array.

Im Falle eines Castings zwischen zwei Datentypen befindet sich an mindestens einer Stelle in der AST Struktur ein \texttt{CastFactor}-Element.
Von diesem Element aus wird der Datentyp des zugehörigen \texttt{factor} geändert, indem dessen Attribut \texttt{castFactor} geändert wird.
Dieses Attribut übersteuert den eigentlichen Datentyp des Elements innerhalb des AST.
Weil der \texttt{factor} gemäss Grammatik unterschiedliche Produktionen besitzt (vgl. Änderungen an der Grammatik), muss die Typanpassung rekursiv weitergegeben werden.
Die Rekursion wird durch Literale oder Expressions unterbrochen, wie am Beispiel in Anhang \ref{bsp_casting} aufgezeigt.

In der virtuellen Maschine wurde ein neuer generischer Typ \texttt{NumData} eingeführt.
Dieser wird für die Konversion zwischen Daten vom Typ \texttt{IntData}\footnote{für den Datentyp \texttt{INT32}} und \texttt{NatData}\footnote{für den Datentyp \texttt{NAT32}} verwendet.
Abbildung \ref{data_hierarchy} zeigt die Klassenhierarchie dieser Typen.

\begin{figure}[H]
    \includegraphics[width=\linewidth]{uml_data_hierarchy.png} % Figure image
    \caption{Daten in VM} % Figure caption
    \label{data_hierarchy}
\end{figure}

Beim Dereferenzieren muss im Falle eines Castings der Datentyp von bereits typisierten Daten auf dem Stack geändert werden.
Anhang \ref{bsp_deref} zeigt ein Beispiel, bei welchem der Datentyp aufgrund des neu propagierten Attributs \texttt{castType} umgewandelt wird.

\subsection{Code Generierung}
\section{Vergleich mit anderen Programmiersprachen}
\subsection{Ganzzahlige Werte}
In Java wird bei Zuweisungen die Länge einer Zahl in Bitdarstellung überprüft:
Beim Datentyp \texttt{long} wird beispielsweise geprüft, ob der Wert als ganzzahliger Wert von 32-bit Länge dargestellt werden kann.
Falls dies nicht der Fall ist, wird ein Fehler zur Kompilierungszeit geworfen.
Das MSB wird als Vorzeichenbit verwendet, womit rund die Hälfte der vorzeichenlos darstellbaren \texttt{long}-Werte entfällt, resp. zur Darstellung von negativen Zahlen eingesetzt wird.
Falls bei fortlaufenden Berechnungen Wertebereiche unter- resp. überschritten werden, führt dies zu einem arithmetischen Überlauf.
Abbildung \ref{zahlenkreis}
zeigt den Überlauf bei ganzzahligen, vorzeichenbehafteten Datentypen (am Beispiel von Bitlänge 3 + 1).

\begin{figure}[H]
    \includegraphics[width=\linewidth]{zahlenkreis_int3.jpg}
    \caption{Überlauf mit Integerzahlen}
    \label{zahlenkreis}
\end{figure}

Dadurch führt z.B. beim Datentyp \texttt{int} der Ausdruck \texttt{Integer.MAX\_VALUE + 1} zum Wert \texttt{Integer.MIN\_VALUE}.
Dies kann dazu führen, dass mit \glqq falschen\grqq \ Werten gerechnet wird, ohne dass der Entwickler dies bemerkt.

\subsection{Fliesskommazahlen}
\label{ieee}
Im Gegensatz zur Darstellung im Zweierkomplement, welches für Integer-Typen in Java verwendet werden, werden Fliesskommazahlen intern nach IEEE Standard dargestellt.
Anders als bei der Zweierkomplement-Darstellung sieht dieses Format spezielle, konstante Werte vor.
So sind in Java beispielsweise Konstanten für \texttt{Double.POSITIVE\_INFINITY}, \texttt{Double.NEGATIVE\_INFINITY} und \texttt{Double.NaN} definiert \footnote{Quelle: }.

\section{Designentscheidungen}
\subsection{Spezifiziertes Verhalten}
Der neue Datentyp \texttt{NAT32} unterstützt die bestehenden Operationen aus IML\footnote{Aktuell sind dies \begin{itemize}
                                                                                                                \item MULTOPR(*, divE, modE) \item ADDOPR(+, -) \item RELOPR(<, <=, >, >=, =, /=) \item BOOLOPR(&&, ||, &, |)
\end{itemize}}.
Sofern sich die einzelnen Operanden und auch das Resulat im Wertebereich\footnote{$[0,4294967295]$} befinden,
entspricht das Verhalten vom Datentyp \texttt{NAT32} jenem vom Datentyp \texttt{INT32}.
Andernfalls wird folgendes Verhalten festgelegt:

\begin{itemize}
    \item \textbf{Wertebereich}: Wertebereichsüber- resp. Unterschreitungen resultieren in einem Laufzeitfehler\footnote{Negative Zahlen entsprechen Wertebereichsunterschreitungen}. Dies erhöht die Typsicherheit beim Einsatz der verschiedenen Datentypen.
    \item \textbf{Nachkommastellen}: Gemäss IML-Spezifikation sind als Literale nur ganzzahlige Werte erlaubt. Falls z.B. bei einer Division ein Rest resultiert, wird ein ganzzahliges Resultat zurückgegeben. Der Wert des Resultats ist abhängig von der gewählten Operation (\texttt{DivFloor, \texttt{DivTrunc}, etc.).}
\end{itemize}

\subsection{Alternative Ansätze}
Folgende weiteren Ansätze wurden für die Umsetzung der Erweiterung in Betracht gezogen:

\begin{itemize}
    \item \textbf{Arithmetischer Überlauf:} Wertebereisüber- resp. unterschreitungen resultieren in einem arithmetischen Überlauf. Gegenüber der Darstellung in Abbildung \ref{zahlenkreis} müsste kein negativer Wertebereich verwendet werden und das Addieren von $+ 1$ zum grössten Darstellbaren Wert des Datentyps \texttt{NAT32} führt zum Wert $0$. Weil auf ein Vorzeichenbit verzichtet werden kann, verdoppelt sich der Wertebereich gegenüber dem Datentyp \texttt{INT32}. Nachteilig ist dabei, dass der Entwickler verantwortlich ist für das Einhalten der Wertebereichsgrenzen.
    \item \textbf{Vordefinierte Konstanten:} Ähnlich wie bei Fliesskommazahlen (vgl. Kapitel \ref{ieee}) könnten konstante Werte für z.B. \texttt{POSITIVE\_INFINITY} und \texttt{NEGATIVE\_INFINITY} vorgesehen werden. Das Verhalten bei Wertebereichsüberschreitungen müsste definiert werden. Nachteilig bei dieser Variante ist, dass der Wertebereich um die Anzahl solcher konstante Werte verringert wird.
    \item \textbf{Absolute Werte:} Bei dieser Variante wird bei negativen Werten deren Absolutwert verwendet. Von dieser initial angedachten Variante wurde abgesehen, weil das Verhalten schnell zu ungewollten Resultaten führen kann.
\end{itemize}

\section{Beispielprogramme}
\label{sec:prog}
Operation:
\begin{lstlisting}
program progAddition
global
    var x:nat32;
    var y:nat32;
    var r:nat32;
    var b:bool
do
    x init := 4;
    y init := 3;
    r init := x + y;
    b init := r = 7;
    debugout r;
    debugout b
endprogram
\end{lstlisting}
Casting:
\begin{lstlisting}
program progCasting
global
    var x:nat32;
    var y:int32;
    var r:nat32;
    var b:bool
do
    x init := 4;
    y init := 3;
    r init := x + [nat32] y;
    b init := r = 7;
    debugout r;
    debugout b
endprogram
\end{lstlisting}

\section{Ausblick - zukünftige Erweiterungsmöglichkeiten}
% TODO: Ist das so für dich OK?
In einer nächsten Erweiterung des Compilers, könnten grössere NAT Datentypen oder auch Floatingdatentypen eingeführt werden.
Ebenfalls wäre es denkbar, zusätzliche mathematische Funktionen einzubauen wie z.B. eine Funktion zur Berechnung des grössten gemeinsamen Teilers (ggT), resp. des kleinste gemeinsame Vielfache (kgV).

\section {Arbeitsteilung}
% TODO: Ist das so für dich OK?
Der Scanner wurde grösstenteils von Marco Romanutti implementiert, während Benjamin Meyer die Grammatik für Fix und Foxi erstellte.
Alle übrigen Arbeiten (Zwischenbericht, Parser, Code-Generierung, Schlussbericht, etc.) wurden gemeinsam durchgeführt.


\section{Unterschrift}
Brugg, 07.01.2020
\\
\\
\\
\\
Marco Romanutti \hfill Benjamin Meyer


%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------
\clearpage
\begin{thebibliography}{9}
    \bibitem{wikipedia_natNumDe}
    Wikipedia: Natürliche Zahl\\
    \url{https://de.wikipedia.org/wiki/Nat\%C3\%BCrliche_Zahl}

    \bibitem{wikipedia_natNumEN}
    Wikipedia: Natural numbers (engl.)\\
    \url{https://en.wikipedia.org/wiki/Natural_number}

    \bibitem{wikipedia_int}
    Wikipedia: Integer (Datentyp)\\
    \url{https://de.wikipedia.org/wiki/Integer_(Datentyp)}

    \bibitem{stack}
    Stackoverflow: Purpose of defining POSITIVE\_INFINITY, NEGATIVE\_INFINITY, NaN constants only for floating-point data types, but not for integral data types\\
    \url{https://stackoverflow.com/questions/41312477/}
\end{thebibliography}

%----------------------------------------------------------------------------------------
%	APPENDIX
%----------------------------------------------------------------------------------------
\clearpage
\appendix
\section{Vollständige Grammatik}
% TODO
\begin{lstlisting}
program ::= PROGRAM IDENT progParamList [GLOBAL cpsDecl] DO cpsCmd ENDPROGRAM

decl ::= stoDecl
        | funDecl
        | procDecl

stoDecl ::= [CHANGEMODE] typedIdent

funDecl ::= FUN IDENT paramList RETURNS stoDecl [GLOBAL globImps] [LOCAL cpsStoDecl] DO cpsCmd ENDFUN

procDecl ::= PROC IDENT paramList [GLOBAL globImps] [LOCAL cpsStoDecl] DO cpsCmd ENDPROC

globImps ::= globImp {COMMA globImp}

globImp ::= [FLOWMODE] [CHANGEMODE] IDENT

cpsDecl ::= decl {SEMICOLON decl}

cpsStoDecl ::= stoDecl {SEMICOLON stoDecl}

progParamList ::= LPAREN [progParam {COMMA progParam}] RPAREN

progParam ::= [FLOWMODE] [CHANGEMODE] typedIdent

paramList ::= LPAREN [param {COMMA param}] RPAREN

param ::= [FLOWMODE] [MECHMODE] [CHANGEMODE] typedIdent

typedIdent ::= IDENT COLON TYPE

cmd ::= SKIP
        | expr BECOMES expr
        | IF expr THEN cpsCmd ELSE cpsCmd ENDIF
        | WHILE expr DO cpsCmd ENDWHILE
        | CALL IDENT exprList [globInits]
        | DEBUGIN expr
        | DEBUGOUT expr

cpsCmd ::= cmd {SEMICOLON cmd}

globInits ::= INIT idents

idents ::= IDENT {COMMA IDENT}

expr ::= term1 {BOOLOPR term1}

term1 ::= term2 [RELOPR term2]

term2 ::= term3 {ADDOPR term3}

term3 ::= factor {MULTOPR factor}

factor ::= LITERAL
        | IDENT [INIT | exprList]
        | monadicOpr factor
        | LPAREN expr RPAREN
        | castOpr factor

castOpr ::= LBRACKET TYPE RBRACKET

exprList ::= LPAREN [expr {COMMA expr}] RPAREN

monadicOpr ::= NOT | ADDOPR
\end{lstlisting}

\clearpage
\section{Beispiel doppeltes Casting}
\label{bsp_casting}
IML:
\begin{lstlisting}
program progDouble
global
    var value:int32
do
    value init := [int32] [nat32] ((4 + 1) + 1)
endprogram
\end{lstlisting}

Code-Array:
\begin{lstlisting}
0: AllocBlock(1)
1: UncondJump(2)
2: LoadAddrAbs(0)
3: LoadImInt(4)
4: LoadImInt(1)
5: AddInt
6: LoadImInt(1)
7: AddInt
8: Store
9: Stop
\end{lstlisting}

UML:
\begin{figure}[H]
    \includegraphics[width=\linewidth]{uml_casting.png} % Figure image
    \caption{Auszug aus AST } % Figure caption
    \label{casting}
\end{figure}

\clearpage
\section{Beispiel \texttt{Deref}}
\label{bsp_deref}
IML:
\begin{lstlisting}
program exampleCasting
global
    var x:int32;
    var y:nat32
do
    x init := [int32] 4;
    y init := [nat32] 3;
    x := [int32] y
endprogram
\end{lstlisting}

Code-Array:
\begin{lstlisting}
0: AllocBlock(1)
1: AllocBlock(1)
2: UncondJump(3)
3: LoadAddrAbs(0)
4: LoadImInt(4)
5: Store
6: LoadAddrAbs(1)
7: LoadImNat(3)
8: Store
9: LoadAddrAbs(0)
10: LoadAddrAbs(1)
11: Deref
12: Store
13: Stop
\end{lstlisting}

Stack:
\begin{lstlisting}
    ...

(8) Executing instruction Store
pc: 8
sp: 4
Stack content:
0: IntData: 4
1: NatData: 3

(9) Executing instruction LoadAddrAbs(0)
pc: 9
sp: 2
Stack content:
0: IntData: 4
1: NatData: 3
2: IntData: 0

(10) Executing instruction LoadAddrAbs(1)
pc: 10
sp: 3
Stack content:
0: IntData: 4
1: NatData: 3
2: IntData: 0
3: IntData: 1

(11) Executing instruction Deref
pc: 11
sp: 4
Stack content:
0: IntData: 4
1: NatData: 3
2: IntData: 0
3: IntData: 3

(12) Executing instruction Store
pc: 12
sp: 4
Stack content:
0: IntData: 3
1: NatData: 3

    ...
\end{lstlisting}

\clearpage
\section{Beispiel casting einer expression}
\label{bsp_casting_expr}
IML:
\begin{lstlisting}
program exampleCastExpression
global
    var x:int32;
    var y:int32;
    var z:nat32;
    var b:bool;
    var c:bool
do
    x init := 4;
    y init := 2;
    z init := [nat32] (x * y + y + x);
    b init := x >= y;
    c init := x >= [int32] z
endprogram
\end{lstlisting}


Code-Array:
\begin{lstlisting}
0: AllocBlock(1)
1: AllocBlock(1)
2: AllocBlock(1)
3: AllocBlock(1)
4: AllocBlock(1)
5: UncondJump(6)
6: LoadAddrAbs(0)
7: LoadImInt(4)
8: Store
9: LoadAddrAbs(1)
10: LoadImInt(2)
11: Store
12: LoadAddrAbs(2)
13: LoadAddrAbs(0)
14: Deref
15: LoadAddrAbs(1)
16: Deref
17: MultInt
18: LoadAddrAbs(1)
19: Deref
20: AddInt
21: LoadAddrAbs(0)
22: Deref
23: AddNat
24: Store
25: LoadAddrAbs(3)
26: LoadAddrAbs(0)
27: Deref
28: LoadAddrAbs(1)
29: Deref
30: GeInt
31: Store
32: LoadAddrAbs(4)
33: LoadAddrAbs(0)
34: Deref
35: LoadAddrAbs(2)
36: Deref
37: GeInt
38: Store
39: Stop
\end{lstlisting}

Stack:
\begin{lstlisting}
    ...
(12) Executing instruction LoadAddrAbs(2)
pc: 12
sp: 5
Stack content:
0: IntData: 4
1: IntData: 2
2: null
3: null
4: null
5: IntData: 2

(13) Executing instruction LoadAddrAbs(0)
pc: 13
sp: 6
Stack content:
0: IntData: 4
1: IntData: 2
2: null
3: null
4: null
5: IntData: 2
6: IntData: 0

(14) Executing instruction Deref
pc: 14
sp: 7
Stack content:
0: IntData: 4
1: IntData: 2
2: null
3: null
4: null
5: IntData: 2
6: IntData: 4

(15) Executing instruction LoadAddrAbs(1)
pc: 15
sp: 7
Stack content:
0: IntData: 4
1: IntData: 2
2: null
3: null
4: null
5: IntData: 2
6: IntData: 4
7: IntData: 1

(16) Executing instruction Deref
pc: 16
sp: 8
Stack content:
0: IntData: 4
1: IntData: 2
2: null
3: null
4: null
5: IntData: 2
6: IntData: 4
7: IntData: 2

(17) Executing instruction MultInt
pc: 17
sp: 8
Stack content:
0: IntData: 4
1: IntData: 2
2: null
3: null
4: null
5: IntData: 2
6: IntData: 8

(18) Executing instruction LoadAddrAbs(1)
pc: 18
sp: 7
Stack content:
0: IntData: 4
1: IntData: 2
2: null
3: null
4: null
5: IntData: 2
6: IntData: 8
7: IntData: 1

(19) Executing instruction Deref
pc: 19
sp: 8
Stack content:
0: IntData: 4
1: IntData: 2
2: null
3: null
4: null
5: IntData: 2
6: IntData: 8
7: IntData: 2

(20) Executing instruction AddInt
pc: 20
sp: 8
Stack content:
0: IntData: 4
1: IntData: 2
2: null
3: null
4: null
5: IntData: 2
6: IntData: 10

(21) Executing instruction LoadAddrAbs(0)
pc: 21
sp: 7
Stack content:
0: IntData: 4
1: IntData: 2
2: null
3: null
4: null
5: IntData: 2
6: IntData: 10
7: IntData: 0

(22) Executing instruction Deref
pc: 22
sp: 8
Stack content:
0: IntData: 4
1: IntData: 2
2: null
3: null
4: null
5: IntData: 2
6: IntData: 10
7: IntData: 4

(23) Executing instruction AddNat
pc: 23
sp: 8
Stack content:
0: IntData: 4
1: IntData: 2
2: null
3: null
4: null
5: IntData: 2
6: NatData: 14

(24) Executing instruction Store
pc: 24
sp: 7
Stack content:
0: IntData: 4
1: IntData: 2
2: NatData: 14
3: null
4: null

    ...
\end{lstlisting}


%----------------------------------------------------------------------------------------

\end{document}
