%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% NAT32 support for IML
% Module cpib
%
% This template was downloaded from:
% http://www.LaTeXTemplates.com
%
% Authors:
% Marco Romanutti
% Benjamin Meyer
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[10pt, a4paper, twocolumn]{article} % 10pt font size (11 and 12 also possible), A4 paper (letterpaper for US letter) and two column layout (remove for one column)

\input{structure.tex} % Specifies the document structure and loads requires packages

%----------------------------------------------------------------------------------------
%	ARTICLE INFORMATION
%----------------------------------------------------------------------------------------

\title{Nat32 und Casting für IML} % The article title

\author{
\authorstyle{Marco Romanutti und Benjamin Meyer\textsuperscript{1,2}} % Authors
\newline\newline % Space before institutions
\textsuperscript{1}\institution{Fachhochschule Nordwestschweiz FHNW, Brugg}\\ % Institution
\textsuperscript{2}\texttt{Schlussbericht} % Module
}

\date{}

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Print the title

\thispagestyle{firstpage} % Apply the page style for the first page (no headers and footers)

%----------------------------------------------------------------------------------------
%	ABSTRACT
%----------------------------------------------------------------------------------------

\lettrineabstract{Im Modul Compilerbau wird eine Erweiterung für die bestehende Sprache IML spezifiziert und implementiert. Die Implementierung beinhaltet einen neuen Datentyp für natürliche Zahlen, sowie eine Möglichkeit den Datentyp Int32 in den neuen Datentypen zu casten und umgekehrt.}
%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\section{Erweiterung}
\subsection{Einleitung}
Unter natürlichen Zahlen werden die positiven, ganzen Zahlen und 0 verstanden:

$$ \mathbb{N} = \{0; 1; 2; 3; \ldots\} $$

Die IML soll um einen neuen Datentyp \texttt{NAT32} erweitert werden.
Der neue Datentyp soll solche positiven, ganzen Zahlen mit einer Länge von bis zu 32 Bits in Binärdarstellung abbilden können.
Es sollen die bestehenden Operationen unterstützt werden.
Ausserdem soll ein explizites Casting zwischen dem bestehenden Datentyp \texttt{INT32} und dem neuen Datentyp \texttt{NAT32} möglich sein.

\subsection{Lexikalische Syntax}
Für den neuen Datentyp wird das Keyword \texttt{(TYPE, NAT32)} und ein Castingoperator hinzugefügt.

% Listing mit neuen Elementen
\begin{lstlisting}[backgroundcolor = \color{lightgray},
xleftmargin = 0.05cm,
framexleftmargin = 0.05em]
    Datentyp:     NAT32     (TYPE, NAT32)
    Brackets:     [ ]       LBRACKET, RBRACKET
\end{lstlisting}

Casting ist nur von \texttt{(TYPE, INT32)} zu \texttt{(TYPE, NAT32)} und umgekehrt möglich.
Als Castingoperator werden rechteckige Klammern (nachfolgend Brackets genannt) verwendet.
Innerhalb der Brackets befindet sich der Zieldatentyp \footnote{zum Beispiel \texttt{[INT32]}}.

\subsection{Grammatikalische Syntax}
Das nachfolgende Code-Listing zeigt, wie der neue Datentyp \texttt{NAT32} eingesetzt werden kann.
\begin{lstlisting}
    // Deklaration
    var natIdent1 : nat32;
    var natIdent2 : nat32;
    var natIdent3 : nat32;

    // Initialisierung
    natIdent1 init := [nat32] 50;
    natIdent2 init := [nat32] 10;
    natIdent3 init := natIdent1 + natIdent2;

    // Casting von INT32 nach NAT32
    var intIdent1 : int32;
    intIdent1 init := 30;
    natIdent3 := [nat32] intIdent1;

    call functionWithNatParam([nat32] intIdent1);

    // Casting von NAT32 nach INT32
    var intIdent2 : int32;
    intIdent2 init := [int32] natIdent3;

    call functionWithIntParam([int32] natIdent3);
\end{lstlisting}
Literale werden standardmässig als \texttt{INT32} interpretiert - ein \texttt{NAT32}-Literal bedingt vorab deshalb den Castingoperator.
Falls zwei Datentypen nicht gecastet werden können, wird ein Kompilierungsfehler geworfen.
Folgendes Code-Listing zeigt ein solches Beispiel mit dem bestehenden Datentyp \texttt{bool}:
\begin{lstlisting}
    // Deklaration
    var boolIdent : bool;
    boolIdent init := false;
    var natIdent : nat32;
    // Throws type checking error:
    natIdent init := [nat32] boolIdent
\end{lstlisting}
Unsere Erweiterung unterstützt keine impliziten Castings.
Weitere Code-Beispiele sind im Anhang zu finden.

Ebenfalls haben wir in unserer IML-Syntax die logischen Symbole für \texttt{AND} (\texttt{/\textbackslash{}}) sowie \texttt{OR} (\texttt{\textbackslash{}/}) durch die Symbole \texttt{\&\&} resp. \texttt{||} ersetzt.
Nach unserem Erachten ist die Bedeutung dieser Symbole den meisten Programmierern geläufiger.

\subsection{Änderungen an der Grammatik}
Zusätzlich zu den bestehenden Operatoren wurde ein neuer \texttt{castOpr} erstellt, welcher anstelle des Nichtterminal-Symbol \texttt{factor} verwendet werden kann.
% Neuer Operator
\begin{lstlisting}[backgroundcolor = \color{lightgray},
xleftmargin = 0.05cm,
framexleftmargin = 0.05em]
    castOpr ::= LBRACKET TYPE RBRACKET
\end{lstlisting}
Das bestehende Nichtterminal-Symbol \texttt{factor} wird um diese neue Produktion ergänzt:
% Neue Produktionen
\begin{lstlisting}[backgroundcolor = \color{lightgray},
xleftmargin = 0.05cm,
framexleftmargin = 0.05em]
    factor ::= LITERAL
              | IDENT [INIT | exprList]
              | castOpr factor
              | monadicOpr factor
              | LPAREN expr RPAREN
\end{lstlisting}

\subsection{Kontext- und Typen-Einschränkungen}
Der \texttt{TYPE} zwischen \texttt{LBRACKET} und \texttt{RBRACKET} muss vom Datentyp \texttt{INT32} oder \texttt{NAT32} sein.
Ein Casting zum Typ \texttt{bool} oder vom Typ \texttt{bool} zu \texttt{INT32} resp. \texttt{NAT32} führt zu einem Kompilierungsfehler.

Tabelle \ref{tab:Casting} zeigt die unterstützen Typumwandlungen der verschiedenen Datentypen.
Typumwandlungen, welche zu potentiellen Laufzeitfehlern führen, sind mit mit \texttt{*} gekennzeichnet.
Der Datentyp \texttt{INT32} umfasst einen Wertebereich von $-2147483648$ bis $2147483647$, wobei das Most Significant Bit (MSB) für das Vorzeichen verwendet wird.
Weil der Datentyp \texttt{NAT32} nur positive, ganze Zahlen und die Zahl 0 darstellt, wird kein Vorzeichenbit benötigt.
Der Wertebereich verschiebt sich dadurch auf $0$ bis $4294967295$.
Falls bei Typumwandlungen der Wert ausserhalb des Wertebereichs des Zieldatentyps liegt, führt dies zu einem Laufzeitfehler.
Bei der Umwandlung von \texttt{NAT32} nach \texttt{INT32} kann ein solcher Laufzeitfehler beispielsweise auftreten, falls es sich um einen Wert $> 2147483647$ handelt.
Falls negative Werte von \texttt{INT32} nach \texttt{NAT32} umgewandelt werden, resultiert ebenfalls ein Laufzeitfehler.
\begin{table}[h]
    \tiny
    \centering
    \caption{Casting zwischen Datentypen}
    \label{tab:Casting}
    \resizebox{\columnwidth}{!}{%
    \begin{tabular}{rlll}
        \hline
        Quell- \textbackslash \ Zieldatentyp & int32 & nat32 & bool \\ \hline
        int32 & \cmark        & \cmark *       & \xmark      \\
        nat32 & \cmark *      & \cmark         & \xmark     \\
        bool & \xmark        & \xmark         & \xmark     \\ \hline
    \end{tabular}%
    }
\end{table}

\section{Aufbau Compiler}
Der Compiler basiert auf der IML (V2) und ist in Java geschrieben.

\subsection{Scanner}
\label{scanner}
Literale werden standardmässig als \texttt{INT32} interpretiert - ein \texttt{NAT32}-Literal bedingt vorab deshalb den Castingoperator.
Vom Scanner werden Literale als \texttt{long} in Java eingelesen.
Dieser Datentyp kann Werte von $-9223372036854775808$ bis $9223372036854775807$ annehmen und deckt somit den gesamten Wertebereich der beiden Datentypen \texttt{INT32} und \texttt{NAT32} ab.
Die Überprüfung, ob der Wert innerhalb des gültigen Wertebereichs des jeweiligen Datentyps liegt, erfolgt zum Zeitpunkt der Code-Generierung.

\subsection{Parser}
Der neu eingeführte \texttt{castOpr} und die neue Produktion \texttt{factor ::= castOpr factor} sind im Abstrakten Syntax Tree (AST) abgebildet.
Dabei wird der Typ \texttt{CastOpr} zum Typ \texttt{CastFactor}, welcher Teil des AST ist.
Abbildung \ref{ast} zeigt die Umwandlung von der konkreten in die abstrakte Syntax.

\begin{figure}[H]
    \includegraphics[width=\linewidth]{uml_ast.png} % Figure image
    \caption{Umwandlung von der konkreten in die abstrakte Syntax} % Figure caption
    \label{ast}
\end{figure}

\subsection{Statische Analyse}

\subsubsection*{Scope checking}
Für Routinen und Variablen liegen unterschiedliche Namespaces vor.
Namen für Routinen und Variabeln können deshalb identisch sein.
Es wird zwischen globalen und lokalen Namespaces unterschieden: Bei lokalen Namespaces werden die Variabeln innerhalb einer Routine definiert und haben dort ihre Gültigkeit.
Globale Variabeln dürfen nicht denselben Namen haben wie lokale Variabeln.
Überladene Signaturen für Routinen\footnote{identischer Name, unterschiedliche Parameterlisten} wurden in dieser Implementation nicht umgesetzt.

Bei \textit{FunCallFactor, ProcCallCmd, DebugInCmd} und \textit{AssignCmd} muss überprüft werden, ob die Parameter den richtigen \texttt{LValue}, resp. \texttt{RValue} besitzen.
Folgende Kombinationen sind dabei allgemein erlaubt:

\begin{table}[h]
    \centering
    \tiny
    \caption{LRValue-Kombinationen}
    \label{tab:lrvalues}
    \resizebox{\columnwidth}{!}{%
    \begin{tabular}{@{}lll@{}}
        \toprule
        Callee & Caller & Resultat                       \\ \midrule
        LValue & LValue & Valid                          \\
        RValue & LValue & Valid (LValue dereferenzieren) \\
        RValue & RValue & Valid                          \\
        LValue & RValue & LRValError \Lightning         \\ \bottomrule
    \end{tabular}%
    }
\end{table}
Bei einem \textit{AssignCmd} muss der Ausdruck links zudem zwingend ein \texttt{LValue} sein.
Bei einem \textit{DebugInCmd} muss es sich ebenfalls um einen \texttt{LValue} handeln, damit der Input-Wert dieser Variable zugewiesen werden kann.

Innerhalb des Scope checkings wird zudem überprüft, ob die Anzahl der erwarteten Parameter mit der Anzahl übergebener Parameter übereinstimmt.

\subsubsection*{Type checking}
Das Casten zwischen zwei Datentypen ist nur für bestimmte Typen erlaubt (vgl. Tabelle \ref{tab:Casting}).
Zusätzlich sind bei der Abarbeitung des AST nur die folgenden Typen erlaubt:

\begin{table}[h]
    \centering
    \tiny
    \caption{Erlaubte Typen im AST}
    \label{tab:types}
    \resizebox{\columnwidth}{!}{%
    \begin{tabular}{@{}ll@{}}
        \toprule
        Klasse & Types \\ \midrule
        AddExpr, MultExpr, RelExpr      & \texttt{int32, nat32} * \\
        BoolExpr, IfCmd                 & \texttt{bool} \\
        AssignCmd                       & \texttt{int32, nat32, bool} * \\
        FunCallFactor, ProcCallFactor   & Typ von Caller muss Typ \\
                                        & von Callee entsprechen \\
        MonadicFactor                   & NOTOPR: \texttt{bool} \\
                                        & ADDOPR: \texttt{int32, nat32} \\
        CastFactor                      & Typ von Factor und Typ \\
                                        & von CastFactor müssen \\
                                        & gecastet werden können\\ \bottomrule
    \end{tabular}%
    }
\end{table}
Bei Einträgen, die mit * gekennzeichnet sind, müssen \texttt{LValue} und \texttt{RValue} vom selben Typ sein.
Bei der Typenüberprüfung innerhalb vom \texttt{CastFactor} wird überprüft, ob der Typ vom \texttt{CastFactor} und jener des zugehörigen \texttt{factors} gecasted werden können (vgl. Tabelle \ref{tab:Casting}).
Die effektive Typ-Konversion wird erst bei der Code-Generierung durchgeführt.

\subsubsection*{Initalization checking}
Beim Initialization checking wird überprüft, ob Variablen noch nicht initialisiert wurden, zuvor bereits einmal initialisiert wurden oder ob das Zuweisen eines Werts zur Variable untersagt ist.
Folgendes Codebeispiel zeigt die verschiedenen Initialisierungsfehler:
\begin{lstlisting}
program exampleInitErrors
global
    var x:int32;
    const y:int32
do
    x := 7; // NotInitializedError

    x init := 4;
    x init := 3; // AlreadyInitializedError

    y init := 1;
    y := 2 // AssignToConstError
endprogram
\end{lstlisting}

\begin{itemize}
    \item \texttt{\textbf{NotInitializedError}}: Die Variable wurde zuvor nicht initialisiert.
    \item \texttt{\textbf{AlreadyInitializedError}}: Die Variable wurde bereits zuvor initialisiert.
    \item \texttt{\textbf{AssignToConstError}}: Die Variable ist eine Konstante und wurde bereits initialisiert.
\end{itemize}

Falls einer dieser Fehler auftritt, wird die Überprüfung sofort beendet und der Initialisierungscheck ist fehlgeschlagen.
Der AST wird während der Validierung Knoten für Knoten durchlaufen, wobei eine "Deep-First" Baumsuche angewendet wird.

\subsection{Virtuelle Maschine}
Grundlage für die Code-Generierung ist der AST.
Vom Root-Knoten ausgehend fügt jeder Knoten seinen Code zum Code-Array.

Im Falle eines Castings zwischen zwei Datentypen befindet sich an mindestens einer Stelle in der AST-Struktur ein \texttt{CastFactor}-Element.
Von diesem Element aus wird der Datentyp des zugehörigen \texttt{factor} geändert, indem dessen Attribut \texttt{castFactor} geändert wird.
Dieses Attribut übersteuert den eigentlichen Datentyp des Elements innerhalb des AST.
Weil der \texttt{factor} gemäss Grammatik unterschiedliche Produktionen besitzt (vgl. Änderungen an der Grammatik), muss die Typanpassung rekursiv weitergegeben werden.
Die Rekursion wird durch Literale oder Expressions unterbrochen, wie am Beispiel in Anhang \ref{bsp_casting} aufgezeigt.

In der virtuellen Maschine wurde ein neuer generischer Typ \texttt{NumData} eingeführt.
Dieser wird für die Konversion zwischen Daten vom Typ \texttt{IntData}\footnote{für den Datentyp \texttt{INT32}} und \texttt{NatData}\footnote{für den Datentyp \texttt{NAT32}} verwendet.
Abbildung \ref{data_hierarchy} zeigt die Klassenhierarchie dieser Typen.

\begin{figure}[H]
    \includegraphics[width=\linewidth]{uml_data_hierarchy.png} % Figure image
    \caption{Daten in VM} % Figure caption
    \label{data_hierarchy}
\end{figure}

Beim Dereferenzieren muss im Falle eines Castings der Datentyp von bereits typisierten Daten auf dem Stack geändert werden.
Anhang \ref{bsp_deref} zeigt ein Beispiel, bei welchem der Datentyp aufgrund des neu propagierten Attributs \texttt{castType} umgewandelt wird.

\subsection{Code Generierung}
\section{Vergleich mit anderen Programmiersprachen}
\subsection{Ganzzahlige Werte}
In Java wird bei Zuweisungen die Länge einer Zahl in Binärdarstellung überprüft:
Beim Datentyp \texttt{long} wird beispielsweise geprüft, ob der Wert als ganzzahliger Wert von 64-bit Länge dargestellt werden kann.
Falls dies nicht der Fall ist, wird ein Fehler zur Kompilierungszeit geworfen.
Das MSB wird als Vorzeichenbit verwendet, womit rund die Hälfte der vorzeichenlos darstellbaren \texttt{long}-Werte entfällt, resp. zur Darstellung von negativen Zahlen eingesetzt wird.
Falls bei fortlaufenden Berechnungen Wertebereiche unter- resp. überschritten werden, führt dies zu einem arithmetischen Überlauf.
Abbildung \ref{zahlenkreis}
zeigt den Überlauf bei ganzzahligen, vorzeichenbehafteten Datentypen (am Beispiel von Bitlänge 3 + 1).

\begin{figure}[H]
    \includegraphics[width=\linewidth]{zahlenkreis_int3.jpg}
    \caption{Überlauf mit Integerzahlen}
    \label{zahlenkreis}
\end{figure}

Dadurch führt z.B. beim Datentyp \texttt{int} der Ausdruck \texttt{Integer.MAX\_VALUE + 1} zum Wert \texttt{Integer.MIN\_VALUE}.
Dies kann dazu führen, dass mit \glqq falschen\grqq \ Werten gerechnet wird, ohne dass der Entwickler dies bemerkt.

\subsection{Fliesskommazahlen}
\label{ieee}
Im Gegensatz zur Darstellung im Zweierkomplement, welches für Integer-Typen in Java verwendet werden, werden Fliesskommazahlen intern nach IEEE Standard dargestellt.
Anders als bei der Zweierkomplement-Darstellung sieht dieses Format spezielle, konstante Werte vor.
So sind in Java beispielsweise Konstanten für \texttt{Double.POSITIVE\_INFINITY}, \texttt{Double.NEGATIVE\_INFINITY} und \texttt{Double.NaN} definiert \footnote{vgl. [4]}.

\section{Designentscheidungen}
\subsection{Spezifiziertes Verhalten}
Der neue Datentyp \texttt{NAT32} unterstützt die bestehenden Operationen aus IML\footnote{Aktuell sind dies \begin{itemize}
                                                                                                                \item MULTOPR(*, divE, modE) \item ADDOPR(+, -) \item RELOPR(<, <=, >, >=, =, /=) \item BOOLOPR(\&\&, ||, \&, |)
\end{itemize}}.
Sofern sich die einzelnen Operanden und auch das Resultat im Wertebereich\footnote{$[0,4294967295]$} befinden,
entspricht das Verhalten vom Datentyp \texttt{NAT32} jenem vom Datentyp \texttt{INT32}.
Andernfalls wird folgendes Verhalten festgelegt:

\begin{itemize}
    \item \textbf{Wertebereich}: Wertebereichsüber- resp. Unterschreitungen resultieren in einem Laufzeitfehler\footnote{Negative Zahlen entsprechen Wertebereichsunterschreitungen}. Dies erhöht die Typsicherheit beim Einsatz der verschiedenen Datentypen.
    \item \textbf{Nachkommastellen}: Gemäss IML-Spezifikation sind als Literale nur ganzzahlige Werte erlaubt. Falls z.B. bei einer Division ein Rest resultiert, wird ein ganzzahliges Resultat zurückgegeben. Der Wert des Resultats ist abhängig von der gewählten Operation\footnote{\texttt{DivFloor}, \texttt{DivTrunc}, etc.}.
\end{itemize}

\subsection{Alternative Ansätze}
Folgende weiteren Ansätze wurden für die Umsetzung der Erweiterung in Betracht gezogen:

\begin{itemize}
    \item \textbf{Arithmetischer Überlauf:} Wertebereisüber- resp. unterschreitungen resultieren in einem arithmetischen Überlauf. Gegenüber der Darstellung in Abbildung \ref{zahlenkreis} müsste kein negativer Wertebereich verwendet werden und das Addieren von $+ 1$ zum grössten Darstellbaren Wert des Datentyps \texttt{NAT32} führt zum Wert $0$. Weil auf ein Vorzeichenbit verzichtet werden kann, verdoppelt sich der Wertebereich gegenüber dem Datentyp \texttt{INT32}. Nachteilig ist dabei, dass der Entwickler verantwortlich ist für das Einhalten der Wertebereichsgrenzen.
    \item \textbf{Vordefinierte Konstanten:} Ähnlich wie bei Fliesskommazahlen (vgl. Kapitel \ref{ieee}) könnten konstante Werte für z.B. \texttt{POSITIVE\_INFINITY} und \texttt{NEGATIVE\_INFINITY} vorgesehen werden. Das Verhalten bei Wertebereichsüberschreitungen müsste definiert werden. Nachteilig bei dieser Variante ist, dass der Wertebereich um die Anzahl solcher konstante Werte verringert wird.
    \item \textbf{Absolute Werte:} Bei dieser Variante wird bei negativen Werten deren Absolutwert verwendet. Von dieser initial angedachten Variante wurde abgesehen, weil das Verhalten schnell zu ungewollten Resultaten führen kann.
\end{itemize}

\section{Diskussion und Ausblick}
Die Erweiterung des Compilers um einen neuen Datentypen für natürliche Zahlen, sowie eine Möglichkeit den Datentyp \texttt{INT32} in den neuen Datentypen zu casten und umgekehrt, konnten erfolgreich umgesetzt werden.
Der Scanner wurde grösstenteils von Marco Romanutti implementiert, während Benjamin Meyer die Grammatik für Fix und Foxi erstellte.
Alle übrigen Arbeiten (Parser, Statische Analyse, Virtuelle Berichte, Berichte, etc.) wurden aufgrund des grossen Aufwands gemeinsam und in fortwährendem Austausch durchgeführt.

Wie in Kapitel \ref{scanner} beschrieben, werden Literale standardmässig als \texttt{INT32} interpretiert.
Literale für den Datentyp \texttt{NAT32} müssen deshalb mit dem Castingoperator gecastet werden.
In einer nächsten Erweiterung des Compilers könnte ein neues Syntaxelement eingefügt werden, mithilfe welchem \texttt{NAT32}-Literale "schöner" gekennzeichnet werden könnten\footnote{vgl. Java Suffix für \texttt{long} (z.B. \texttt{39537L}), \texttt{float} (z.B. \texttt{1.4f}) und \texttt{double} (z.B. \texttt{-7.439d})}.
Weiter könnten Datentypen mit einer Länge von mehr als 32 Bit in Binärdarstellung oder auch Floatingdatentypen eingeführt werden.
Ebenfalls denkbar wären zusätzliche mathematische Funktionen einzubauen, wie z.B. eine Funktion zur Berechnung des grössten gemeinsamen Teilers (ggT), resp. des kleinsten gemeinsamen Vielfachen (kgV).

%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------
\begin{thebibliography}{9}
    \bibitem{wikipedia_natNumDe}
    Wikipedia: Natürliche Zahl\\
    \url{https://de.wikipedia.org/wiki/Nat\%C3\%BCrliche_Zahl}

    \bibitem{wikipedia_natNumEN}
    Wikipedia: Natural numbers (engl.)\\
    \url{https://en.wikipedia.org/wiki/Natural_number}

    \bibitem{wikipedia_int}
    Wikipedia: Integer (Datentyp)\\
    \url{https://de.wikipedia.org/wiki/Integer_(Datentyp)}

    \bibitem{stack}
    Stackoverflow: Purpose of defining POSITIVE\_INFINITY, NEGATIVE\_INFINITY, NaN constants only for floating-point data types, but not for integral data types\\
    \url{https://stackoverflow.com/questions/41312477/}
\end{thebibliography}

\clearpage
\section*{}
\vspace{18cm}
Brugg, 07.01.2020
\\
\\
\\
\\
\\
Marco Romanutti \hfill Benjamin Meyer




%----------------------------------------------------------------------------------------
%	APPENDIX
%----------------------------------------------------------------------------------------
\clearpage
\appendix
\onecolumn
\section{Vollständige Grammatik}
% TODO
\begin{lstlisting}[backgroundcolor = \color{lightgray},
xleftmargin = 0.05cm,
framexleftmargin = 0.05em]
 program       ::= PROGRAM IDENT progParamList [GLOBAL cpsDecl] DO cpsCmd ENDPROGRAM

 decl          ::= stoDecl
                   | funDecl
                   | procDecl

 stoDecl       ::= [CHANGEMODE] typedIdent

 funDecl       ::= FUN IDENT paramList RETURNS stoDecl [GLOBAL globImps] [LOCAL cpsStoDecl]
                    DO cpsCmd ENDFUN
 procDecl      ::= PROC IDENT paramList [GLOBAL globImps] [LOCAL cpsStoDecl] DO cpsCmd ENDPROC

 globImps      ::= globImp {COMMA globImp}

 globImp       ::= [FLOWMODE] [CHANGEMODE] IDENT

 cpsDecl       ::= decl {SEMICOLON decl}

 cpsStoDecl    ::= stoDecl {SEMICOLON stoDecl}

 progParamList ::= LPAREN [progParam {COMMA progParam}] RPAREN

 progParam     ::= [FLOWMODE] [CHANGEMODE] typedIdent

 paramList     ::= LPAREN [param {COMMA param}] RPAREN

 param         ::= [FLOWMODE] [MECHMODE] [CHANGEMODE] typedIdent

 typedIdent    ::= IDENT COLON TYPE

 cmd           ::= SKIP
                   | expr BECOMES expr
                   | IF expr THEN cpsCmd ELSE cpsCmd ENDIF
                   | WHILE expr DO cpsCmd ENDWHILE
                   | CALL IDENT exprList [globInits]
                   | DEBUGIN expr
                   | DEBUGOUT expr

 cpsCmd        ::= cmd {SEMICOLON cmd}

 globInits     ::= INIT idents

 idents        ::= IDENT {COMMA IDENT}

 expr          ::= term1 {BOOLOPR term1}

 term1         ::= term2 [RELOPR term2]
 term2         ::= term3 {ADDOPR term3}
 term3         ::= factor {MULTOPR factor}

 factor        ::= LITERAL
                   | IDENT [INIT | exprList]
                   | monadicOpr factor
                   | LPAREN expr RPAREN
                   | castOpr factor

 castOpr       ::= LBRACKET TYPE RBRACKET

 exprList      ::= LPAREN [expr {COMMA expr}] RPAREN

 monadicOpr    ::= NOT | ADDOPR
\end{lstlisting}

\clearpage
\twocolumn
\section{Beispiel Scanner}
IML:
\begin{lstlisting}
    This file should lex successfully:

    Liebe Grossmutter:

    Zu Deinen 67-ten Geburtstag wuensche ich Dir alles Gute,

    Dein Beat

    &&   ||   program++-*endprogram


    whilex==17do//
    xwhile:=5

    x_'_'17   1000''100'10

    // A Comment
    no comment

    mod modE
    [NAT32]
\end{lstlisting}

Token-List:
\begin{lstlisting}
[(IDENT, "This"), (IDENT, "file"), (IDENT, "should"), (IDENT, "lex"), (IDENT, "successfully"), COLON, (IDENT, "Liebe"), (IDENT, "Grossmutter"), COLON, (IDENT, "Zu"), (IDENT, "Deinen"), (LITERAL, 67), (ADDOPR, MINUS), (IDENT, "ten"), (IDENT, "Geburtstag"), (IDENT, "wuensche"), (IDENT, "ich"), (IDENT, "Dir"), (IDENT, "alles"), (IDENT, "Gute"), COMMA, (IDENT, "Dein"), (IDENT, "Beat"), (BOOLOPR, CAND), (BOOLOPR, COR), PROGRAM, (ADDOPR, PLUS), (ADDOPR, PLUS), (ADDOPR, MINUS), (MULTOPR, TIMES), ENDPROGRAM, (IDENT, "whilex"), (RELOPR, EQ), (RELOPR, EQ), (LITERAL, 17), DO, (IDENT, "xwhile"), BECOMES, (LITERAL, 5), (IDENT, "x__17"), (LITERAL, 100010010), (IDENT, "no"), (IDENT, "comment"), (MULTOPR, MOD), (MULTOPR, MOD_E), LBRACKET, (IDENT, "NAT32"), RBRACKET, SENTINEL ]
\end{lstlisting}

\clearpage
\section{Beispiel \texttt{init}}
IML:
\begin{lstlisting}
program exampleInit
global
    var x:int32;
    var y:nat32
do
    x init := [int32] 4;
    y init := [nat32] 3
endprogram
\end{lstlisting}

Concrete Syntax Tree:
\begin{lstlisting}
PROGRAM
(IDENT, "exampleInit")
 GLOBAL
    (CHANGEMOD, VAR)
     (IDENT, "x")
     COLON
     (TYPE, INT32)
   SEMICOLON
    (CHANGEMOD, VAR)
     (IDENT, "y")
     COLON
     (TYPE, NAT32)
DO
     (IDENT, "x")
      INIT
  BECOMES
       LBRACKET
       (TYPE, INT32)
       RBRACKET
       (LITERAL, 4)
  SEMICOLON
     (IDENT, "y")
      INIT
  BECOMES
       LBRACKET
       (TYPE, NAT32)
       RBRACKET
       (LITERAL, 3)
ENDPROGRAM
\end{lstlisting}

\newpage
\vspace*{0.3cm}
Abstract Syntax Tree:
\begin{lstlisting}
ch.fhnw.edu.cpib.ast.Program
 [localStoresNamespace]:
 [globalStoresNamespace]:
 [globalRoutinesNamespace]:
 <ident>: (IDENT, "exampleInit")
 <globalDeclarations>:
  ch.fhnw.edu.cpib.ast.StoDecl
   [localStoresNamespace]:
   <changeMode>: VAR
   <typeIdent>:
    ch.fhnw.edu.cpib.ast.TypedIdent
    [localStoresNamespace]:
    (<ident>, <type>): ((IDENT, "x"), INT32)
  ch.fhnw.edu.cpib.ast.StoDecl
   [localStoresNamespace]:
   <changeMode>: VAR
   <typeIdent>:
    ch.fhnw.edu.cpib.ast.TypedIdent
     [localStoresNamespace]:
     (<ident>, <type>): ((IDENT, "y"), NAT32)
 <cpsCmd>:  ch.fhnw.edu.cpib.ast.CpsCmd
   [localStoresNamespace]:
   <commands>:
    ch.fhnw.edu.cpib.ast.AssignCmd
    [localStoresNamespace]:
    <exprLeft>:
     ch.fhnw.edu.cpib.ast.InitFactor
      [localStoresNamespace]:
      <init>: true
    <exprRight>:
     ch.fhnw.edu.cpib.ast.CastFactor
      [localStoresNamespace]:
      <CastType>: INT32
      <factor>:
       ch.fhnw.edu.cpib.ast.LiteralFactor
        [localStoresNamespace]:
        <literal>: (LITERAL, 4)
    ch.fhnw.edu.cpib.ast.AssignCmd
     [localStoresNamespace]:
     <exprLeft>:
      ch.fhnw.edu.cpib.ast.InitFactor
       [localStoresNamespace]:
       <init>: true
     <exprRight>:
      ch.fhnw.edu.cpib.ast.CastFactor
       [localStoresNamespace]:
       <CastType>: NAT32
       <factor>:
        ch.fhnw.edu.cpib.ast.LiteralFactor
         [localStoresNamespace]:
         <literal>: (LITERAL, 3)
\end{lstlisting}

\clearpage
\section{Beispiel doppeltes Casting}
\label{bsp_casting}
IML:
\begin{lstlisting}
program exampleDouble
global
    var value:int32
do
    value init := [int32] [nat32] ((4 + 1) + 1)
endprogram
\end{lstlisting}

Code-Array:
\begin{lstlisting}
0: AllocBlock(1)
1: UncondJump(2)
2: LoadAddrAbs(0)
3: LoadImInt(4)
4: LoadImInt(1)
5: AddInt
6: LoadImInt(1)
7: AddInt
8: Store
9: Stop
\end{lstlisting}

UML:
\begin{figure}[H]
    \includegraphics[width=\linewidth]{uml_casting.png} % Figure image
    \caption{Auszug aus AST } % Figure caption
    \label{casting}
\end{figure}

\clearpage
\section{Beispiel \texttt{Deref}}
\label{bsp_deref}
IML:
\begin{lstlisting}
program exampleCasting
global
    var x:int32;
    var y:nat32
do
    x init := [int32] 4;
    y init := [nat32] 3;
    x := [int32] y
endprogram
\end{lstlisting}

Code-Array:
\begin{lstlisting}
0: AllocBlock(1)
1: AllocBlock(1)
2: UncondJump(3)
3: LoadAddrAbs(0)
4: LoadImInt(4)
5: Store
6: LoadAddrAbs(1)
7: LoadImNat(3)
8: Store
9: LoadAddrAbs(0)
10: LoadAddrAbs(1)
11: Deref
12: Store
13: Stop
\end{lstlisting}

\newpage
\vspace*{0.3cm}
Stack:
\begin{lstlisting}
    ...

(8) Executing instruction Store
pc: 8
sp: 4
Stack content:
0: IntData: 4
1: NatData: 3

(9) Executing instruction LoadAddrAbs(0)
pc: 9
sp: 2
Stack content:
0: IntData: 4
1: NatData: 3
2: IntData: 0

(10) Executing instruction LoadAddrAbs(1)
pc: 10
sp: 3
Stack content:
0: IntData: 4
1: NatData: 3
2: IntData: 0
3: IntData: 1

(11) Executing instruction Deref
pc: 11
sp: 4
Stack content:
0: IntData: 4
1: NatData: 3
2: IntData: 0
3: IntData: 3

(12) Executing instruction Store
pc: 12
sp: 4
Stack content:
0: IntData: 3
1: NatData: 3

    ...
\end{lstlisting}

\clearpage
\section{Beispiel Casting \texttt{expr}}
\label{bsp_expr}
IML:
\begin{lstlisting}
program exampleCastExpression
global
    var x:int32;
    var y:int32;
    var z:nat32;
    var b:bool;
    var c:bool
do
    x init := 4;
    y init := 2;
    z init := [nat32] (x * y + y + x);
    b init := x >= y;
    c init := x >= [int32] z
endprogram
\end{lstlisting}


Code-Array:
\begin{lstlisting}
0: AllocBlock(1)
1: AllocBlock(1)
2: AllocBlock(1)
3: AllocBlock(1)
4: AllocBlock(1)
5: UncondJump(6)
6: LoadAddrAbs(0)
7: LoadImInt(4)
8: Store
9: LoadAddrAbs(1)
10: LoadImInt(2)
11: Store
12: LoadAddrAbs(2)
13: LoadAddrAbs(0)
14: Deref
15: LoadAddrAbs(1)
16: Deref
17: MultInt
18: LoadAddrAbs(1)
19: Deref
20: AddInt
21: LoadAddrAbs(0)
22: Deref
23: AddNat
24: Store
25: LoadAddrAbs(3)
26: LoadAddrAbs(0)
27: Deref
28: LoadAddrAbs(1)
29: Deref
30: GeInt
31: Store
32: LoadAddrAbs(4)
33: LoadAddrAbs(0)
34: Deref
35: LoadAddrAbs(2)
36: Deref
37: GeInt
38: Store
39: Stop
\end{lstlisting}

\clearpage
\section{Beispiel Factorial}
IML:
\begin{lstlisting}
program exampleFactorial
    global
    const input:nat32;
    const result:int32;
    proc factorial(copy const value:int32, ref var factorial:int32)
    local
        var counter:int32
        do
            counter init := value;
            factorial := 1;
            while counter > 1 do
                factorial := factorial * counter;
                counter := counter - 1
            endwhile
        endproc
do
    debugin input init;
    call factorial([int32] input, result init);
        debugout result
endprogram
\end{lstlisting}

Output bei Input $4$:

\texttt{result:int32 => 24} \cmark
%----------------------------------------------------------------------------------------

\end{document}
